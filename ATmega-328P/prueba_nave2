#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

#define botonArriba PC0
#define botonIzquierda PC1
#define botonDerecha PC2
#define botonAbajo PC3

#define VELOCIDAD_FACIL 3000
#define VELOCIDAD_MEDIA 2000
#define VELOCIDAD_DIFICIL 1000

uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t piedras_esquivadas = 0;
uint8_t vidas = 3;

uint8_t nave_pos_x = 3;  // Posición de la nave en el eje X (columnas)
uint8_t nave_pos_y = 7;  // Posición de la nave en el eje Y (filas)

const uint8_t carita_feliz[] = {0x00, 0x14, 0x20, 0x40, 0x40, 0x20, 0x14, 0x00};
const uint8_t carita_triste[] = {0x00, 0x64, 0x10, 0x10, 0x10, 0x10, 0x64, 0x00};
const uint8_t visto[] = {0x00, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00};

// Declaración de la función delay_ms() para que esté disponible en todo el código
void delay_ms(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        _delay_ms(1);  // Llamar a la función _delay_ms() de AVR
    }
}

void init_matriz() {
    DDRD = 0xFF;  // Establece el puerto D como salida (Filas)
    DDRB = 0xFF;  // Establece el puerto B como salida (Columnas)
}

void limpiar_matriz() {
    PORTD = 0x00;  // Apaga todas las filas (en ánodo común, 0 activa)
    PORTB = 0xFF;  // Apaga todas las columnas (en ánodo común, 1 desactiva)
}

void mostrar_pixel(uint8_t fila, uint8_t columna) {
    if (fila < 8 && columna < 8) {
        PORTB = ~(1 << columna);  // Activar la columna (poner 0 para ánodo común)
        PORTD = (1 << fila);      // Activar la fila (poner 1 para ánodo común)
        delay_ms(10);  // Retardo para que el pixel se quede visible
        limpiar_matriz();
    }
}

void mostrar_carita(const uint8_t* carita) {
    for (uint8_t i = 0; i < 8; i++) {
        // Mostrar cada fila de la carita en la matriz 8x8
        PORTB = carita[i];
        delay_ms(200);
        limpiar_matriz();
    }
}

void mostrar_puntaje(uint16_t puntaje) {
    uint8_t col_puntaje = puntaje % 8;
    for (uint8_t i = 0; i < 5; i++) {
        limpiar_matriz();
        mostrar_pixel(0, col_puntaje);
        delay_ms(150);
        limpiar_matriz();
        delay_ms(150);
    }
}

void nave() {
    // Representación de la nave en la matriz como un triángulo
    uint8_t nave[] = {0x01, 0x03, 0x07, 0x03, 0x01};  // Triángulo simple en la matriz
    limpiar_matriz();  // Limpiar la matriz antes de mostrar la nave
    for (uint8_t i = 0; i < 5; i++) {
        if (nave_pos_y == i) {
            PORTB = nave[i];  // Mostrar la nave en la posición Y
            mostrar_pixel(i, nave_pos_x); // Mostrar en la fila y columna de la nave
            delay_ms(200);  // Mostrar la nave durante 200 ms
        }
    }
}

void controlar_nave() {
    if (PINC & (1 << botonArriba) && nave_pos_y > 0) {
        nave_pos_y--;  // Mover la nave hacia arriba
    }
    if (PINC & (1 << botonAbajo) && nave_pos_y < 7) {
        nave_pos_y++;  // Mover la nave hacia abajo (pero no más allá de la última fila)
    }
    if (PINC & (1 << botonIzquierda) && nave_pos_x > 0) {
        nave_pos_x--;  // Mover la nave a la izquierda
    }
    if (PINC & (1 << botonDerecha) && nave_pos_x < 7) {
        nave_pos_x++;  // Mover la nave a la derecha
    }
}

void crear_piedra(uint8_t* piedras, uint8_t *pos_x) {
    // Genera la posición aleatoria de la piedra en la primera fila
    *pos_x = rand() % 8;  // Posición aleatoria en X (columna)
    piedras[*pos_x] = 0x80;  // Activa la columna correspondiente en la fila 0
}

void mover_piedra(uint8_t* piedras) {
    uint8_t desplazamiento_aleatorio;
    for (uint8_t i = 0; i < 8; i++) {
        if (piedras[i] != 0) {
            // Desplazar la piedra hacia abajo en la columna i
            for (uint8_t j = 0; j < 7; j++) {
                mostrar_pixel(j + 1, i);  // Mueve la piedra hacia abajo
                limpiar_matriz();
                delay_ms(velocidad_actual);  // Control del tiempo de retardo según el nivel
            }
            piedras[i] = 0;  // Borrar la piedra de la posición anterior

            // Si la piedra llega a la última fila, reiniciar en la parte superior
            desplazamiento_aleatorio = rand() % 3 - 1;  // Aleatorio entre -1, 0 o 1
            if (i + desplazamiento_aleatorio >= 0 && i + desplazamiento_aleatorio < 8) {
                piedras[i + desplazamiento_aleatorio] = 0x80;
            }
        }
    }
}

void esquivar() {
    if (piedras_esquivadas % 5 == 0) {
        mostrar_pixel(0, 0);  // Mostrar un "visto"
        piedras_esquivadas = 0;  // Reiniciar contador de piedras esquivadas
        nivel++;  // Aumentar el nivel después de 5 piedras esquivadas
        if (nivel > 3) {
            // Si pasa el último nivel, mostrar carita feliz y reiniciar
            mostrar_carita(carita_feliz);
            puntaje += 1000;  // Aumentar puntaje al completar el juego
            nivel = 1;  // Reiniciar nivel
        }
    }

    // Aumentar la velocidad de las piedras según el nivel
    switch (nivel) {
        case 1:
            velocidad_actual = VELOCIDAD_FACIL;
            break;
        case 2:
            velocidad_actual = VELOCIDAD_MEDIA;
            break;
        case 3:
            velocidad_actual = VELOCIDAD_DIFICIL;
            break;
        default:
            velocidad_actual = VELOCIDAD_FACIL;
            break;
    }

    // Incrementar puntaje dependiendo del nivel
    if (nivel == 1) {
        puntaje += 200;
    } else if (nivel == 2) {
        puntaje += 500;
    } else {
        puntaje += 550;
    }
}

void game_over() {
    // Función para cuando el jugador pierda
    mostrar_puntaje(puntaje);  // Muestra el puntaje actual
    delay_ms(2000);  // Esperar 2 segundos
    mostrar_carita(carita_triste);  // Muestra carita triste
    vidas--;  // Restar vida
    if (vidas == 0) {
        // Si no hay vidas, reiniciar el juego
        nivel = 1;
        puntaje = 0;
        piedras_esquivadas = 0;
        vidas = 3;
    }
}

void iniciar_juego() {
    // Esperar a que el botón de inicio sea presionado (botón Arriba)
    while (!(PINC & (1 << botonArriba))) {
        // Espera activa hasta que el botón de inicio sea presionado
        limpiar_matriz();
        delay_ms(100);
    }
    delay_ms(2000);  // Esperar 2 segundos antes de empezar el juego
    limpiar_matriz();
    nave();  // Mostrar la nave
    delay_ms(2000);  // Mostrar la nave durante 2 segundos sin movimiento
}

void actualizar_juego() {
    nave();  // Mostrar la nave
    controlar_nave();  // Controlar la nave con los botones

    // Generar nuevas piedras y moverlas
    static uint8_t piedras[8] = {0};  // Almacena las piedras en las columnas
    static uint8_t pos_x = 0;

    crear_piedra(piedras, &pos_x);  // Crear una nueva piedra aleatoria
    mover_piedra(piedras);  // Mover las piedras

    esquivar();  // Verificar si se esquivaron piedras
}

int main() {
    init_matriz();

    // Esperar hasta que se presione el botón de inicio
    iniciar_juego();
    
    while (1) {
        actualizar_juego();  // Llamada a la función que actualiza la nave y las piedras
        
        if (vidas == 0) {
            game_over();  // Si el jugador ha perdido, mostrar Game Over
        }
    }
}
