#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

#define botonArriba PC0
#define botonIzquierda PC1
#define botonDerecha PC2
#define botonAbajo PC3

#define VELOCIDAD_FACIL 3
#define VELOCIDAD_MEDIA 2
#define VELOCIDAD_DIFICIL 1

uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t esquivadas = 0;
uint8_t piedras_caidas = 0;

void init_matriz() {
  DDRD = 0xFF; // Configura todos los pines del puerto D como salida
  DDRB = 0xFF; // Configura todos los pines del puerto B como salida
}

void limpiar_matriz() {
    PORTD = 0xFF;
    PORTB = 0xFF;
}

void mostrar_puntaje(uint16_t puntaje) {
    uint8_t col_puntaje = puntaje % 8;
    for (uint8_t i = 0; i < 5; i++) {
        limpiar_matriz();
        mostrar_pixel(0, col_puntaje);
        _delay_ms(150);
        limpiar_matriz();
        _delay_ms(150);
    }
}

void seleccionar_nivel(uint8_t nivel) {
    switch (nivel) {
        case 1:
            velocidad_actual = VELOCIDAD_FACIL;
            break;
        case 2:
            velocidad_actual = VELOCIDAD_MEDIA;
            break;
        case 3:
            velocidad_actual = VELOCIDAD_DIFICIL;
            break;
        default:
            velocidad_actual = VELOCIDAD_FACIL;
    }
}

void delay_variable(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        _delay_ms(1);
    }
}

void mover_nave(char* nave, uint8_t direccion) {
  // Función para mover la nave dependiendo de la dirección
  switch(direccion) {
    case 1: // Mover arriba
      nave[0] = nave[0] >> 1;
      nave[1] = nave[1] >> 1;
      break;
    case 2: // Mover abajo
      nave[0] = nave[0] << 1;
      nave[1] = nave[1] << 1;
      break;
    case 3: // Mover izquierda
      nave[0] = (nave[0] >> 1) | (nave[0] << 7);
      nave[1] = (nave[1] >> 1) | (nave[1] << 7);
      break;
    case 4: // Mover derecha
      nave[0] = (nave[0] << 1) | (nave[0] >> 7);
      nave[1] = (nave[1] << 1) | (nave[1] >> 7);
      break;
  }
}

void jugador() {
  char nave[] = {
    0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Posición inicial
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0  // Posición final
  };

  // Mover la nave según los botones
  if (PINC & (1 << botonArriba)) {
    mover_nave(nave, 1);
  }
  if (PINC & (1 << botonAbajo)) {
    mover_nave(nave, 2);
  }
  if (PINC & (1 << botonIzquierda)) {
    mover_nave(nave, 3);
  }
  if (PINC & (1 << botonDerecha)) {
    mover_nave(nave, 4);
  }
}

void piedras() {
  char piedras[8] = {0};
  
  // Hacer que las piedras caigan de manera aleatoria
  for (int i = 0; i < 8; i++) {
    if (rand() % 2) {
      piedras[i] = 0x01;
    }
  }
}

void esquivar() {
  // Verifica si la nave esquivó la piedra
  if (/* condición para esquivar */) {
    esquivadas++;
    puntaje += (nivel == 1) ? 200 : (nivel == 2) ? 500 : 550;
    if (esquivadas == 5) {
      esquivadas = 0;
      nivel++;
      if (nivel > 3) {
        mostrar_carita_feliz();
        reiniciar_juego();
      }
    }
  }
}

void mostrar_carita_feliz() {
  // Muestra una carita feliz en la matriz
  limpiar_matriz();
  mostrar_pixel(0, 0); // Aquí puedes cambiar el patrón para mostrar una carita feliz
  _delay_ms(1000);
}

void mostrar_carita_triste() {
  // Muestra una carita triste en la matriz
  limpiar_matriz();
  mostrar_pixel(0, 0); // Aquí puedes cambiar el patrón para mostrar una carita triste
  _delay_ms(1000);
}

void reiniciar_juego() {
  // Reinicia el juego
  nivel = 1;
  puntaje = 0;
  esquivadas = 0;
  piedras_caidas = 0;
  limpiar_matriz();
  _delay_ms(1000);
}

int main() {
  init_matriz();
  while (1) {
    // Jugador
    jugador();

    // Lógica de caída de piedras y esquivar
    if (piedras_caidas % 5 == 0) {
      piedras();
      esquivar();
    }

    // Mostrar puntaje
    mostrar_puntaje(puntaje);

    // Lógica de nivel
    seleccionar_nivel(nivel);

    // Incrementar caída de piedras
    piedras_caidas++;

    // Control de velocidad de caída de las piedras
    delay_variable(velocidad_actual * 1000);
  }

  return 0;
}
