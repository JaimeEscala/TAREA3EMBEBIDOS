#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

// Definir botones
#define botonArriba     PC0
#define botonIzquierda  PC1
#define botonDerecha    PC2
#define botonAbajo      PC3

// Velocidades
#define VELOCIDAD_FACIL   300
#define VELOCIDAD_MEDIA   200
#define VELOCIDAD_DIFICIL 100

// Variables de control
uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t piedras_esquivadas = 0;
uint8_t vidas = 3;

uint8_t nave_pos_x = 3;
uint8_t nave_pos_y = 7;

// Caritas
const uint8_t carita_feliz[] = {0x00, 0x14, 0x20, 0x40, 0x40, 0x20, 0x14, 0x00};
const uint8_t carita_triste[] = {0x00, 0x64, 0x10, 0x10, 0x10, 0x10, 0x64, 0x00};
const uint8_t visto[] = {0x00, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00};

// Declaración
void mostrar_carita(const uint8_t* carita);
void mostrar_puntaje(uint16_t puntaje);
void delay_ms(uint16_t ms);

// Inicializar hardware
void init_matriz() {
    DDRD = 0xFF;  // Filas
    DDRB = 0xFF;  // Columnas
}

void init_botones() {
    DDRC &= ~((1 << botonArriba) | (1 << botonAbajo) | (1 << botonIzquierda) | (1 << botonDerecha));
    PORTC |= (1 << botonArriba) | (1 << botonAbajo) | (1 << botonIzquierda) | (1 << botonDerecha); // Pull-ups
}

void limpiar_matriz() {
    PORTD = 0x00;
    PORTB = 0xFF;
}

void mostrar_pixel(uint8_t fila, uint8_t columna) {
    if (fila < 8 && columna < 8) {
        PORTB = ~(1 << columna);  // 0 activa columna
        PORTD = (1 << fila);      // 1 activa fila
        delay_ms(10);
        limpiar_matriz();
    }
}

void mostrar_nave() {
    mostrar_pixel(nave_pos_y, nave_pos_x);
}

void controlar_nave() {
    if (!(PINC & (1 << botonArriba)) && nave_pos_y > 6) nave_pos_y--;
    if (!(PINC & (1 << botonAbajo)) && nave_pos_y < 7) nave_pos_y++;
    if (!(PINC & (1 << botonIzquierda)) && nave_pos_x > 0) nave_pos_x--;
    if (!(PINC & (1 << botonDerecha)) && nave_pos_x < 7) nave_pos_x++;
}

void crear_piedra(uint8_t* piedras, uint8_t* pos_x) {
    *pos_x = rand() % 8;
    piedras[*pos_x] = 0x80;  // Bit más alto representa fila 0
}

void mover_piedra(uint8_t* piedras) {
    for (uint8_t i = 0; i < 8; i++) {
        if (piedras[i] != 0) {
            uint8_t fila = 0;
            while (piedras[i] != 0x01) {
                mostrar_pixel(fila, i);
                delay_ms(velocidad_actual);
                limpiar_matriz();

                piedras[i] >>= 1;  // Baja una fila
                fila++;
                
                // Verificar colisión
                if (fila == nave_pos_y && i == nave_pos_x) {
                    game_over();
                    return;
                }
            }

            // Piedra llegó al fondo sin colisión
            piedras[i] = 0;
            piedras_esquivadas++;
        }
    }
}

void esquivar() {
    if (piedras_esquivadas >= 5) {
        piedras_esquivadas = 0;
        nivel++;
        if (nivel > 3) {
            mostrar_carita(carita_feliz);
            puntaje += 1000;
            nivel = 1;
        }
    }

    switch (nivel) {
        case 1: velocidad_actual = VELOCIDAD_FACIL; break;
        case 2: velocidad_actual = VELOCIDAD_MEDIA; break;
        case 3: velocidad_actual = VELOCIDAD_DIFICIL; break;
        default: velocidad_actual = VELOCIDAD_FACIL; break;
    }

    // Puntaje por nivel
    if (nivel == 1) puntaje += 200;
    else if (nivel == 2) puntaje += 500;
    else puntaje += 550;
}

void mostrar_carita(const uint8_t* carita) {
    for (uint8_t i = 0; i < 8; i++) {
        PORTB = ~carita[i];
        PORTD = (1 << i);
        delay_ms(100);
        limpiar_matriz();
    }
}

void mostrar_puntaje(uint16_t puntaje) {
    uint8_t col = puntaje % 8;
    for (uint8_t i = 0; i < 5; i++) {
        mostrar_pixel(0, col);
        delay_ms(150);
        limpiar_matriz();
        delay_ms(150);
    }
}

void game_over() {
    mostrar_puntaje(puntaje);
    delay_ms(1000);
    mostrar_carita(carita_triste);
    vidas--;
    if (vidas == 0) {
        nivel = 1;
        puntaje = 0;
        vidas = 3;
        piedras_esquivadas = 0;
    }
}

void iniciar_juego() {
    while (PINC & (1 << botonArriba));  // Esperar que se presione
    delay_ms(1000);
    limpiar_matriz();
    mostrar_nave();
    delay_ms(1000);
}

void delay_ms(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        _delay_ms(1);
    }
}

void actualizar_juego() {
    static uint8_t piedras[8] = {0};
    static uint8_t pos_x = 0;

    mostrar_nave();
    controlar_nave();

    crear_piedra(piedras, &pos_x);
    mover_piedra(piedras);

    esquivar();
}

int main() {
    init_matriz();
    init_botones();
    iniciar_juego();

    while (1) {
        actualizar_juego();
        if (vidas == 0) {
            game_over();
        }
    }
}
