#define F_CPU 8000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

// Definir botones
#define botonArriba     PC0
#define botonIzquierda  PC1
#define botonDerecha    PC2
#define botonAbajo      PC3

// Pines para comunicación con PIC
#define PIN_PC4      PC4  // Para bit 0
#define PIN_PC5      PC5  // Para bit 1

// Velocidades
#define VELOCIDAD_FACIL   300
#define VELOCIDAD_MEDIA   200
#define VELOCIDAD_DIFICIL 100

// Variables globales
uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t piedras_esquivadas = 0;
uint8_t vidas = 3;

uint8_t nave_pos_x = 3;
uint8_t nave_pos_y = 7;

// Caritas para pantalla matriz
const uint8_t carita_feliz[] = {0x00, 0x14, 0x20, 0x40, 0x40, 0x20, 0x14, 0x00};
const uint8_t carita_triste[] = {0x00, 0x64, 0x10, 0x10, 0x10, 0x10, 0x64, 0x00};
const uint8_t visto[] = {0x00, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00};

// Prototipos
void mostrar_carita(const uint8_t* carita);
void mostrar_puntaje(uint16_t puntaje);
void delay_ms(uint16_t ms);
void game_over();
void enviar_senal_perder();
void enviar_senal_ganar();
void enviar_senal_inicio();
void iniciar_juego();
void controlar_nave();
void mostrar_nave();
void limpiar_matriz();
void crear_piedra(uint8_t* piedras, uint8_t* pos_x);
void mover_piedra(uint8_t* piedras);
void esquivar();
void verificar_ganar();
void actualizar_juego();

void init_matriz() {
    DDRD = 0xFF;  // Filas como salida
    DDRB = 0xFF;  // Columnas como salida
}

void init_botones() {
    DDRC &= ~((1 << botonArriba) | (1 << botonAbajo) | (1 << botonIzquierda) | (1 << botonDerecha));
    PORTC |= (1 << botonArriba) | (1 << botonAbajo) | (1 << botonIzquierda) | (1 << botonDerecha); // pull-up activado
}

void init_comunicacion_pic() {
    DDRC |= (1 << PIN_PC4) | (1 << PIN_PC5);  // PC4 y PC5 como salidas
    PORTC &= ~((1 << PIN_PC4) | (1 << PIN_PC5)); // inicio en 00
}

void limpiar_matriz() {
    PORTD = 0x00;
    PORTB = 0xFF;
}

void mostrar_pixel(uint8_t fila, uint8_t columna) {
    if (fila < 8 && columna < 8) {
        PORTB = ~(1 << columna);  // activar columna (0)
        PORTD = (1 << fila);      // activar fila (1)
        delay_ms(10);
        limpiar_matriz();
    }
}

void mostrar_nave() {
    mostrar_pixel(nave_pos_y, nave_pos_x);
}

void controlar_nave() {
    if (!(PINC & (1 << botonArriba)) && nave_pos_y > 0) nave_pos_y--;
    if (!(PINC & (1 << botonAbajo)) && nave_pos_y < 7) nave_pos_y++;
    if (!(PINC & (1 << botonIzquierda)) && nave_pos_x > 0) nave_pos_x--;
    if (!(PINC & (1 << botonDerecha)) && nave_pos_x < 7) nave_pos_x++;
}

void crear_piedra(uint8_t* piedras, uint8_t* pos_x) {
    *pos_x = rand() % 8;
    piedras[*pos_x] = 0x80;  // piedra empieza en fila 0 (bit más alto)
}

void mover_piedra(uint8_t* piedras) {
    for (uint8_t i = 0; i < 8; i++) {
        if (piedras[i] != 0) {
            uint8_t fila = 0;
            uint8_t temp_piedra = piedras[i];
            while (temp_piedra != 0x01) {
                mostrar_pixel(fila, i);
                delay_ms(velocidad_actual);
                limpiar_matriz();

                temp_piedra >>= 1;  // bajar fila
                fila++;

                // Verificar colisión con nave
                if (fila == nave_pos_y && i == nave_pos_x) {
                    game_over();
                    return;
                }
            }
            // Piedra esquivada
            piedras[i] = 0;
            piedras_esquivadas++;
        }
    }
}

void esquivar() {
    if (piedras_esquivadas >= 5) {
        piedras_esquivadas = 0;
        nivel++;
        if (nivel > 3) {
            mostrar_carita(carita_feliz);
            puntaje += 1000;
            nivel = 1;
        }
    }
    switch (nivel) {
        case 1: velocidad_actual = VELOCIDAD_FACIL; break;
        case 2: velocidad_actual = VELOCIDAD_MEDIA; break;
        case 3: velocidad_actual = VELOCIDAD_DIFICIL; break;
        default: velocidad_actual = VELOCIDAD_FACIL; break;
    }

    // Puntaje por nivel
    if (nivel == 1) puntaje += 200;
    else if (nivel == 2) puntaje += 500;
    else puntaje += 550;
}

void mostrar_carita(const uint8_t* carita) {
    for (uint8_t i = 0; i < 8; i++) {
        PORTB = ~carita[i];
        PORTD = (1 << i);
        delay_ms(100);
        limpiar_matriz();
    }
}

void mostrar_puntaje(uint16_t puntaje) {
    uint8_t col = puntaje % 8;
    for (uint8_t i = 0; i < 5; i++) {
        mostrar_pixel(0, col);
        delay_ms(150);
        limpiar_matriz();
        delay_ms(150);
    }
}

void game_over() {
    mostrar_puntaje(puntaje);
    delay_ms(1000);
    mostrar_carita(carita_triste);
    vidas--;

    // Enviar señal perder (01)
    enviar_senal_perder();

    if (vidas == 0) {
        nivel = 1;
        puntaje = 0;
        vidas = 3;
        piedras_esquivadas = 0;
    }
}

void enviar_senal_perder() {
    // PC4=1, PC5=0 → 01
    PORTC = (PORTC & ~((1 << PIN_PC4) | (1 << PIN_PC5))) | (1 << PIN_PC4);
    _delay_ms(100);
    PORTC &= ~((1 << PIN_PC4) | (1 << PIN_PC5)); // limpiar
}

void enviar_senal_ganar() {
    // PC4=0, PC5=1 → 10
    PORTC = (PORTC & ~((1 << PIN_PC4) | (1 << PIN_PC5))) | (1 << PIN_PC5);
    _delay_ms(100);
    PORTC &= ~((1 << PIN_PC4) | (1 << PIN_PC5)); // limpiar
}

void enviar_senal_inicio() {
    // PC4=1, PC5=1 → 11
    PORTC = (PORTC & ~((1 << PIN_PC4) | (1 << PIN_PC5))) | (1 << PIN_PC4) | (1 << PIN_PC5);
    _delay_ms(100);
    PORTC &= ~((1 << PIN_PC4) | (1 << PIN_PC5)); // limpiar
}

void iniciar_juego() {
    // Esperar a que se presione botón arriba para iniciar
    while (PINC & (1 << botonArriba));
    // Enviar señal de inicio al PIC
    enviar_senal_inicio();

    delay_ms(1000);
    limpiar_matriz();
    mostrar_nave();
    delay_ms(1000);
}

void verificar_ganar() {
    if (puntaje >= 3000) {  // condición ejemplo para ganar
        enviar_senal_ganar();
        mostrar_carita(carita_feliz);
        puntaje = 0;
        nivel = 1;
        piedras_esquivadas = 0;
    }
}

void actualizar_juego() {
    static uint8_t piedras[8] = {0};
    static uint8_t pos_x = 0;

    mostrar_nave();
    controlar_nave();

    crear_piedra(piedras, &pos_x);
    mover_piedra(piedras);

    esquivar();
}

void delay_ms(uint16_t ms) {
    for (uint16_t i = 0; i < ms; i++) {
        _delay_ms(1);
    }
}

int main() {
    init_matriz();
    init_botones();
    init_comunicacion_pic();
    iniciar_juego();

    while (1) {
        actualizar_juego();

        if (vidas == 0) {
            game_over();
        }

        verificar_ganar();

        delay_ms(50);
    }
}
