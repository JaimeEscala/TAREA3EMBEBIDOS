#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

#define botonArriba PC0
#define botonIzquierda PC1
#define botonDerecha PC2
#define botonAbajo PC3

#define VELOCIDAD_FACIL 3000
#define VELOCIDAD_MEDIA 2000
#define VELOCIDAD_DIFICIL 1000

uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t piedras_esquivadas = 0;
uint8_t vidas = 3;

uint8_t nave_pos_x = 3;  // Posición de la nave en el eje X (columnas)
uint8_t nave_pos_y = 7;  // Posición de la nave en el eje Y (filas)

const uint8_t carita_feliz[] = {0x00, 0x14, 0x20, 0x40, 0x40, 0x20, 0x14, 0x00};
const uint8_t carita_triste[] = {0x00, 0x64, 0x10, 0x10, 0x10, 0x10, 0x64, 0x00};
const uint8_t visto[] = {0x00, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00};

void init_matriz() {
    DDRD = 0xFF;  // Establece el puerto D como salida (Filas)
    DDRB = 0xFF;  // Establece el puerto B como salida (Columnas)
}

void limpiar_matriz() {
    PORTD = 0xFF;
    PORTB = 0xFF;
}

void mostrar_pixel(uint8_t fila, uint8_t columna) {
    if (fila < 8 && columna < 8) {
        PORTB = ~(1 << columna);  // Activar la columna (inverso para ánodo común)
        PORTD = ~(1 << fila);  // Activar la fila (inverso para ánodo común)
        _delay_ms(10);  // Retardo para que el pixel se quede visible
        limpiar_matriz();
    }
}

void seleccionar_nivel(uint8_t nivel) {
    switch (nivel) {
        case 1:
            velocidad_actual = VELOCIDAD_FACIL;
            break;
        case 2:
            velocidad_actual = VELOCIDAD_MEDIA;
            break;
        case 3:
            velocidad_actual = VELOCIDAD_DIFICIL;
            break;
        default:
            velocidad_actual = VELOCIDAD_FACIL;
    }
}

void mostrar_puntaje(uint16_t puntaje) {
    uint8_t col_puntaje = puntaje % 8;
    for (uint8_t i = 0; i < 5; i++) {
        limpiar_matriz();
        mostrar_pixel(0, col_puntaje);
        _delay_ms(150);
        limpiar_matriz();
        _delay_ms(150);
    }
}

void delay_variable(uint16_t ms) {
    // Divide el retardo en ms unitarios para evitar error _delay_ms()
    for (uint16_t i = 0; i < ms; i++) {
        _delay_ms(1);
    }
}

void init_adc() {
    ADMUX = (1 << REFS0);
    ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
}

uint16_t leer_adc() {
    ADCSRA |= (1 << ADSC);
    while (ADCSRA & (1 << ADSC));
    return ADC;
}

void mostrar_carita(const uint8_t* carita) {
    for (uint8_t i = 0; i < 8; i++) {
        // Mostrar cada fila de la carita en la matriz 8x8
        PORTB = carita[i];
        _delay_ms(200);
        limpiar_matriz();
    }
}

void nave() {
    // Representación de la nave en la matriz como un triángulo
    uint8_t nave[] = {0x01, 0x03, 0x07, 0x03, 0x01};  // Triángulo simple en la matriz
    limpiar_matriz();  // Limpiar la matriz antes de mostrar la nave
    PORTB = nave[nave_pos_x];  // Mostrar la nave en la posición X
    _delay_ms(200);  // Mostrar la nave durante 200 ms
}

void controlar_nave() {
    if (PINC & (1 << botonArriba) && nave_pos_y > 0) {
        nave_pos_y--;  // Mover la nave hacia arriba
    }
    if (PINC & (1 << botonAbajo) && nave_pos_y < 7) {
        nave_pos_y++;  // Mover la nave hacia abajo
    }
    if (PINC & (1 << botonIzquierda) && nave_pos_x > 0) {
        nave_pos_x--;  // Mover la nave a la izquierda
    }
    if (PINC & (1 << botonDerecha) && nave_pos_x < 7) {
        nave_pos_x++;  // Mover la nave a la derecha
    }
}

void crear_piedra(uint8_t* piedras, uint8_t *pos_x, uint8_t *pos_y) {
    // Genera la posición aleatoria de la piedra
    *pos_x = rand() % 8;  // Posición aleatoria en X (columna)
    *pos_y = 0;  // Inicia desde la fila 0 (parte superior)
    piedras[*pos_x] = 0x01 << *pos_x;  // Activa la columna correspondiente
}

void mover_piedra(uint8_t* piedras, uint8_t* pos_y) {
    for (uint8_t i = 0; i < 8; i++) {
        if (piedras[i] != 0) {
            // Desplaza la piedra hacia abajo
            PORTB = piedras[i];  // Mostrar la piedra
            limpiar_matriz();  // Limpiar la matriz
            _delay_ms(velocidad_actual);  // Espera por el nivel
            piedras[i] = 0;  // Borrar la piedra de la posición anterior
            if (*pos_y < 7) {
                *pos_y = *pos_y + 1;  // Mueve la piedra hacia abajo
            } else {
                // Si la piedra llega al fondo, reiniciar en la parte superior
                *pos_y = 0;
            }
            piedras[i] = 0x01 << *pos_y;  // Actualiza la posición de la piedra
        }
    }
}

void esquivar() {
    if (piedras_esquivadas % 5 == 0) {
        mostrar_pixel(0, 0);  // Mostrar un "visto"
        piedras_esquivadas = 0;  // Reiniciar contador de piedras esquivadas
        nivel++;  // Aumentar el nivel después de 5 piedras esquivadas
        if (nivel > 3) {
            // Si pasa el último nivel, mostrar carita feliz y reiniciar
            mostrar_carita(carita_feliz);
            puntaje += 1000;  // Aumentar puntaje al completar el juego
            nivel = 1;  // Reiniciar nivel
        }
    }
    // Incrementar puntaje dependiendo del nivel
    if (nivel == 1) {
        puntaje += 200;
    } else if (nivel == 2) {
        puntaje += 500;
    } else {
        puntaje += 550;
    }
}

void game_over() {
    // Función para cuando el jugador pierda
    mostrar_puntaje(puntaje);  // Muestra el puntaje actual
    _delay_ms(2000);  // Esperar 2 segundos
    mostrar_carita(carita_triste);  // Muestra carita triste
    vidas--;  // Restar vida
    if (vidas == 0) {
        // Si no hay vidas, reiniciar el juego
        nivel = 1;
        puntaje = 0;
        piedras_esquivadas = 0;
        vidas = 3;
    }
}

int main() {
    init_matriz();
    uint8_t piedras[8] = {0};  // Almacena las piedras en las columnas
    uint8_t pos_x = 0, pos_y = 0;
    while (1) {
        nave();  // Mostrar la nave
        controlar_nave();  // Controlar la nave con los botones
        crear_piedra(piedras, &pos_x, &pos_y);  // Crear una nueva piedra
        mover_piedra(piedras, &pos_y);  // Mover las piedras
        esquivar();  // Verificar si se esquivaron piedras
        if (vidas == 0) {
            game_over();  // Si el jugador ha perdido, mostrar Game Over
        }
    }
}
