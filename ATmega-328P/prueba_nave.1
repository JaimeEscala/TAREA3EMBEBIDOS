//NuevoPIPIPI
#define F_CPU 1000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>

#define botonArriba PC0
#define botonIzquierda PC1
#define botonDerecha PC2
#define botonAbajo PC3

#define VELOCIDAD_FACIL 3000
#define VELOCIDAD_MEDIA 2000
#define VELOCIDAD_DIFICIL 1000

uint16_t velocidad_actual = VELOCIDAD_FACIL;
uint16_t puntaje = 0;
uint8_t nivel = 1;
uint8_t esquivadas = 0;
uint8_t piedras_caidas = 0;
uint8_t game_over = 0;

// Posición de la nave (fila, columna)
int8_t nave_pos_fila = 7;
int8_t nave_pos_col = 3;

// Matriz para mostrar en la pantalla LED
uint8_t matriz[8] = {0};

// Patrones para las caritas
const uint8_t carita_feliz[] = {0x00, 0x14, 0x20, 0x40, 0x40, 0x20, 0x14, 0x00};
const uint8_t carita_triste[] = {0x00, 0x64, 0x10, 0x10, 0x10, 0x10, 0x64, 0x00};
const uint8_t visto[] = {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40};

// Declaraciones adelantadas de funciones
void init_matriz();
void limpiar_matriz();
void mostrar_matriz();
void mostrar_patron(const uint8_t *patron);
void mostrar_nave();
void mover_nave();
void generar_piedras();
uint8_t verificar_colision();
void actualizar_juego();
void reiniciar_juego();
void seleccionar_nivel();

void init_matriz() {
    DDRD = 0xFF; // Configura todos los pines del puerto D como salida
    DDRB = 0xFF; // Configura todos los pines del puerto B como salida
}

void limpiar_matriz() {
    for (uint8_t i = 0; i < 8; i++) {
        matriz[i] = 0;
    }
}

void mostrar_matriz() {
    for (uint8_t i = 0; i < 8; i++) {
        PORTD = ~(1 << i); // Seleccionar fila
        PORTB = ~matriz[i]; // Encender columnas
        _delay_ms(1);
    }
}

void mostrar_patron(const uint8_t *patron) {
    for (uint8_t i = 0; i < 8; i++) {
        matriz[i] = patron[i];
    }
}

void mostrar_nave() {
    // Dibujar triángulo (nave) en su posición actual
    if (nave_pos_fila >= 0 && nave_pos_fila < 8 && nave_pos_col >= 0 && nave_pos_col < 8) {
        matriz[nave_pos_fila] |= (1 << nave_pos_col);
        if (nave_pos_fila > 0) {
            matriz[nave_pos_fila-1] |= (1 << nave_pos_col);
        }
        if (nave_pos_fila < 7) {
            matriz[nave_pos_fila+1] |= (1 << nave_pos_col);
        }
    }
}

void mover_nave() {
    static uint8_t debounce = 0;
    
    if (debounce > 0) {
        debounce--;
        return;
    }
    
    if ((PINC & (1 << botonArriba)) && nave_pos_fila > 0) {
        nave_pos_fila--;
        debounce = 10;
    }
    if ((PINC & (1 << botonAbajo)) && nave_pos_fila < 7) {
        nave_pos_fila++;
        debounce = 10;
    }
    if ((PINC & (1 << botonIzquierda)) && nave_pos_col > 0) {
        nave_pos_col--;
        debounce = 10;
    }
    if ((PINC & (1 << botonDerecha)) && nave_pos_col < 7) {
        nave_pos_col++;
        debounce = 10;
    }
}

void generar_piedras() {
    // Mover todas las piedras hacia abajo
    for (int8_t i = 6; i >= 0; i--) {
        matriz[i+1] |= matriz[i] & 0x7E; // 0x7E para evitar los bordes (01111110)
        matriz[i] &= ~0x7E;
    }
    
    // Generar nueva piedra en la fila superior con espacio de 2
    if ((rand() % 3) == 0) { // Probabilidad de 1/3 para generar piedra
        uint8_t col = (rand() % 6) + 1; // Columnas 1-6
        matriz[0] |= (1 << col);
    }
}

uint8_t verificar_colision() {
    // Verificar si la nave chocó con una piedra
    if (matriz[nave_pos_fila] & (1 << nave_pos_col)) {
        return 1;
    }
    if (nave_pos_fila > 0 && (matriz[nave_pos_fila-1] & (1 << nave_pos_col))) {
        return 1;
    }
    if (nave_pos_fila < 7 && (matriz[nave_pos_fila+1] & (1 << nave_pos_col))) {
        return 1;
    }
    return 0;
}

void seleccionar_nivel() {
    switch (nivel) {
        case 1: velocidad_actual = VELOCIDAD_FACIL; break;
        case 2: velocidad_actual = VELOCIDAD_MEDIA; break;
        case 3: velocidad_actual = VELOCIDAD_DIFICIL; break;
        default: velocidad_actual = VELOCIDAD_FACIL;
    }
}

void reiniciar_juego() {
    nivel = 1;
    puntaje = 0;
    esquivadas = 0;
    piedras_caidas = 0;
    game_over = 0;
    nave_pos_fila = 7;
    nave_pos_col = 3;
    limpiar_matriz();
    seleccionar_nivel();
}

void actualizar_juego() {
    static uint32_t ultimo_tiempo = 0;
    static uint32_t ahora = 0;
    
    mover_nave();
    
    ahora++;
    if (ahora - ultimo_tiempo >= (velocidad_actual / 10)) {
        ultimo_tiempo = ahora;
        generar_piedras();
        piedras_caidas++;
        
        if (!verificar_colision()) {
            // Piedra esquivada
            if (piedras_caidas % 5 == 0) {
                esquivadas++;
                switch(nivel) {
                    case 1: puntaje += 200; break;
                    case 2: puntaje += 500; break;
                    case 3: puntaje += 550; break;
                }
                
                if (esquivadas >= 3) { // 3 grupos de 5 piedras (15 total)
                    if (nivel < 3) {
                        nivel++;
                        esquivadas = 0;
                        mostrar_patron(visto);
                        _delay_ms(1000);
                    } else {
                        // Juego completado
                        mostrar_patron(carita_feliz);
                        _delay_ms(2000);
                        reiniciar_juego();
                    }
                }
            }
        } else {
            // Colisión - game over
            game_over = 1;
        }
    }
}

int main() {
    init_matriz();
    seleccionar_nivel();
    
    while (1) {
        limpiar_matriz();
        
        if (game_over) {
            // Mostrar puntaje final
            for (uint8_t i = 0; i < 8; i++) {
                matriz[i] = (puntaje >> (i * 2)) & 0x03;
            }
            mostrar_matriz();
            _delay_ms(2000);
            
            // Mostrar carita triste
            mostrar_patron(carita_triste);
            _delay_ms(2000);
            
            reiniciar_juego();
            continue;
        }
        
        actualizar_juego();
        mostrar_nave();
        mostrar_matriz();
    }
    
    return 0;
}
